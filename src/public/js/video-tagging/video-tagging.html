
<!--
       * video-tagging control for video tagging
       * Main file of the video-tagging module.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="video-taggingstyles.html">
<link rel="import" href="optional-tags.html">
<link rel="import" href="playback-control.html">

<dom-module id="video-tagging">
<template>
    <style include="video-taggingstyles"></style>
    <link rel="stylesheet" href="css/sliders.css" />
    <link rel="stylesheet" href="../jquery-ui/themes/base/resizable.css">
    <link rel="stylesheet" href="css/imgareaselect-animated.css" />
    <link rel="stylesheet" href="../bootstrap/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="assets/icons/style.css">

    <div id="controlWrapper" class="controlWrapper">
        <playback-control id="playSpeedControl" class="playSpeedControl"></playback-control>
        <div id='videoWrapper' class="relativeDiv">
            <div id="ctZone">
                <div id="toolbarZone">
                    <svg id="toolbarSVG">
                        <defs>
                            <filter id="black-glow">
                                <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
                                <feOffset dx="0" dy="0" result="offsetblur" />
                                <feComponentTransfer>
                                    <feFuncA type="linear" slope="0.8" />
                                </feComponentTransfer>
                                <feMerge>
                                    <feMergeNode />
                                    <feMergeNode in="SourceGraphic" />
                                </feMerge>
                            </filter>
                        </defs>
                    </svg>
                </div>
                <div id="selectionZone">
                    <svg id="selectionSVG" class="selectionZoneStyle">
                        <defs>
                            <filter id="black-glow">
                                <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
                                <feOffset dx="0" dy="0" result="offsetblur" />
                                <feComponentTransfer>
                                    <feFuncA type="linear" slope="0.8" />
                                </feComponentTransfer>
                                <feMerge>
                                    <feMergeNode />
                                    <feMergeNode in="SourceGraphic" />
                                </feMerge>
                            </filter>
                        </defs>
                    </svg>
                    <canvas id="overlay" on-click='videoClicked' class="overlaystyle" width="100" height="100">
                        Your browser does not support the HTML5 canvas location.
                    </canvas>
                    <canvas id='frameCanvas' class="frameCanvasStyle" width="100" height="100">

                    </canvas>

                    <video id='vid' class="videoStyle">
                        Your browser does not support the video location.
                    </video>
                </div>
            </div>
        </div>
        <div id="videoControls" class="videoControls">
            <div id="seekDiv" class="seekWrapper">
                <input id="seekBar" class="seek clickableControl" type="range" min='0' value="0" step="any" onkeydown="return false;"
                    required />
            </div>
            <table id="videoControlsTable" class="videoControlsTable">
                <tr>
                    <td class="videoControlCell simpleControl clickableControl">
                        <span id="stepbwd" title="prev" class="icon-backward2 taggingControls" on-click='stepBwdClicked'></span>
                    </td>
                    <td class="videoControlCell simpleControl clickableControl">
                        <span id="play-pause" title="play/pause" class="icon-play3 taggingControls" on-click='playPauseClicked'></span>
                    </td>
                    <td class="videoControlCell simpleControl clickableControl">
                        <span id="stepfwd" title="next" class="icon-forward3 taggingControls" on-click='stepFwdClicked'></span>
                    </td>
                    <td class="videoControlCell simpleControl clickableControl">
                        <span id="nextuntagged" title="first untagged frame" class="icon-next2 taggingControls"
                            on-click='nextUntaggedClicked'></span>
                    </td>
                    <td class="videoControlCell simpleControl clickableControl">
                        <span id="clearRegions" title="clear tags" class="glyphicon glyphicon-ban-circle taggingControls"
                            on-click='clearRegions'></span>
                    </td>
                    <td id="rotate" class="videoControlCell simpleControl clickableControl" style="display: none">
                        <span title="rotate right" class="glyphicon glyphicon-repeat taggingControls" on-click="rotate"></span>
                    </td>
                    <td class="videoControlCell frameNumber">
                        <input type='text' id='frameText' class="textElements" title="frame#"></span>
                    </td>
                    <td id="playSpeedCell" title="play speed" class="videoControlCell longControl clickableControl"
                        style="display: none">
                        <span id="playbackSpan" class="textElements" on-click="playbackSpeedClicked">x 1.0</span>
                    </td>
                    <td nowrap="nowrap" class="videoControlCell simpleControl">
                        <span id="timeSpan" class="textElements"></span>
                    </td>
                    <td class="videoControlCell simpleControl clickableControl" style="display: none">
                        <span id="mute" title="Mute" class="icon-volume-medium taggingControls" on-click='muteClicked'></span>
                    </td>
                    <td class="volumeControlCell longControl" style="display: none">
                        <input id="volumeSlider" class="volume clickableControl" type="range" min=0 max=1 value=.5 step=.1
                            required />
                    </td>

                </tr>
            </table>
        </div>
        <div id="videoTagControls" class="videoTagControls">
            <div class="optionalTags">
                <div class="optionalTagsWrapper">
                    <optional-tags id="optionalTags"></optional-tags>
                </div>
            </div>
            <div class="labelControls">
                <span id="emptyFrame" title="empty frame" class="icon-share taggingControls controlOff" on-click='emptyFrameClicked'></span>
                <span id="lockTag" title="lock tags" class="icon-pushpin taggingControls lockTag controlOff" on-click='lockTagsClicked'></span>
            </div>
            <div class="addTagControls">
                <form id="addTagForm">
                    <input type="text" id="newTag">
                    <input type="submit" value="Add Tag">
                </form>
            </div>
            <div style="clear: both">
              </div>
            <div style="clear: both">
            </div>
        </div>
    </div>
</template>
<script>

  
  Polymer({
    is: 'video-tagging',
    properties: {
      framerate: Number,
      videoduration: Number,
      videowidth: Number,
      videoheight: Number,
      regiontype: String,
      multiregions: Number,
      regionsize: Number,
      imagelist: Object,
      inputtagsarray:Object,
      inputframes: Object,
      src: {
        type: String,
        value: '',
        observer: 'videoSrcChanged'
      }
    },
    // Element Lifecycle
    ready: function() {
        const path = require('path');
        
        this.frames = {}; //Holds the data of the tagged frames, their regions and tags
        this.seeking = false; //Flag for enabling control over the seek bar while the video is playing, see playingCallback function
        this.sequencePlaying = false; //Flag for holding playback state of an image sequence
        this.selectedRegionId = []; //Holds the current selected region number
        this.lockTagsEnabled = false;
        this.selectedTags = [];
        this.uniqueTagId = 0;
        this.videoStartTime = 0; //sometimes videos don't load at absoultue zero
        this.canMove = true;
        this.imageIndex = 0;
        this.curImg = new Image();
        this.rotation = 0;
        this.prevFrameIndex = 0;
        this.multiselection = false;
        this.newTagIndex = null;

        //Frame view size
        this.frameWidth = 0;
        this.frameHeight = 0;

        this.sourceWidth = 0;
        this.sourceHeight = 0;

        //Divs and spans
        this.controlWrapper= this.$$('#controlWrapper');
        this.videoWrapper= this.$$('#videoWrapper');
        this.overlay = this.$$('#overlay');
        this.video= this.$$('#vid');
        this.frameCanvas = this.$$('#frameCanvas');

        this.optionalTags= this.$$('#optionalTags');
        this.regionLabelSpan = this.$$('#regionLabelSpan');
        this.timeSpan = this.$$('#timeSpan');
        this.frameText = this.$$("#frameText");
        this.playbackSpan = this.$$("#playbackSpan");

        //Form
        this.form = this.$$('#addTagForm'),

        // Buttons
        this.playButton = this.$$('#play-pause');
        this.stepfwd = this.$$("#stepfwd");
        this.stepbwd = this.$$("#stepbwd");
        this.lockTag = this.$$("#lockTag");
        this.playSpeedControl = this.$$("#playSpeedControl");
        this.playSpeedCell = this.$$("#playSpeedCell");
        this.mute = this.$$('#mute');
        this.emptyFrame = this.$$("#emptyFrame");
        this.nextuntagged = this.$$("#nextuntagged");
        // Sliders
        this.seekBar = this.$$("#seekBar");
        this.volumeSlider = this.$$("#volumeSlider");
        //dynamic styles for sliders
        this.volumeStyle = document.createElement('style');
        Polymer.dom(this.root).appendChild(this.volumeStyle);
        this.seekStyle = document.createElement('style');
        Polymer.dom(this.root).appendChild(this.seekStyle);
        this.playing = null;
        this.ctx = this.overlay.getContext("2d");
        this.aspect = 0;
        this.snapWidth = 0;

        // Init CanvasTools
        this.initCanvasTools();
    },

    initCanvasTools() {
        this.selectionSVG = document.getElementById("selectionSVG");
        this.toolbarSVG = document.getElementById("toolbarSVG");

        this.CT = CanvasTools.CanvasTools;

        this.regionsManager = new this.CT.Region.RegionsManager(this.selectionSVG, () => { }, () => { });

        this.areaSelector = new this.CT.Selection.AreaSelector(this.selectionSVG,
        {
            onSelectionBegin: () => {
                this.selectionSVG.style.zIndex = 300;
            },
            onSelectionEnd: (commit) => {
                let r = commit.boundRect;
                this.selectionSVG.style.zIndex = 30;
                this.onNewAreaSelected(r.x1, r.y1, r.x2, r.y2);
            },
            onLocked: () => {
                this.regionsManager.freeze();
            },
            onUnlocked: () => {
                this.regionsManager.unfreeze();
            }
        });

        this.regionsManager.onManipulationEnd = () => {
            this.areaSelector.enable();
        };
        this.regionsManager.onManipulationBegin = () => {
            this.areaSelector.disable();
        };

        this.regionsManager.onRegionSelected = (id, multiselection) => {
            this.selectRegion(id, multiselection);
        };

        this.regionsManager.onRegionMove = (id, x, y, width, height) => {
            this.regionMoved(id, x, y, width, height);
        };

        this.regionsManager.onRegionDelete = (id) => {
            this.deleteRegionById(id);
        };

        // Fulfill toolbar
        this.toolbar = new this.CT.Toolbar.Toolbar(toolbarSVG);
        let selectionMode = "rect-select";

        let rectIcont = new this.CT.Toolbar.IconDescription(
            "rect-select",
            "public/js/video-tagging/assets/icons/ct/rect-selection.svg",
            "Rectangular box (R)",
            'KeyR');

        this.toolbar.addAction(rectIcont, (action) => {
            this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.RECT);
        });

        let copyTemplateIcon = new this.CT.Toolbar.IconDescription(
            "copy-select",
            "public/js/video-tagging/assets/icons/ct/copy-t-selection.svg",
            "Copy-based box (T)",
            'KeyT');

        this.toolbar.addAction(copyTemplateIcon, (action) => {
            let rs = this.regionsManager.getSelectedRegionsBounds();
            if (rs !== undefined && rs.length > 0) {
                let r = rs[0];
                this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.COPYRECT, { template: new this.CT.Base.Rect.Rect(r.width, r.height) });
            } else {
                this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.COPYRECT, { template: new this.CT.Base.Rect.Rect(40, 40) });
            }
        });

        let clickTemplateIcon = new this.CT.Toolbar.IconDescription(
            "click-select",
            "public/js/video-tagging/assets/icons/ct/click-selection.svg",
            "Two-Point Mode (P)",
            'KeyP');

        this.toolbar.addAction(clickTemplateIcon, (action) => {
            //right now this just does what the first icon does
            this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.RECT);
        });

        let selectionLockIcon = new this.CT.Toolbar.IconDescription(
            "selection-lock",
            "public/js/video-tagging/assets/icons/ct/selection-lock.svg",
            "Lock/unlock selection (L)",
            'KeyL',
            true);

        this.toolbar.addAction(selectionLockIcon, (action) => {
            this.areaSelector.toggleLockState();
        });

        this.toolbar.select("rect-select");

        // Register empty filter pipeline
        this.filterPipeline = new this.CT.Filter.FilterPipeline();;
    },

    /**
       * Events registration and handling
       *
       * @method attached
       * Events registration and handling
       */
    attached: function() {
        //Reset all variables to new src
        this.video.addEventListener( "loadedmetadata", init);
        var self = this;
      
        function init() {
            self.controlWrapper.style.display = "grid";
            //Init variables and controls
            self.frames = self.inputframes? self.inputframes:{};
            self.frameTime = 1/self.framerate;
            self.optionalTags.createTagControls(self.inputtagsarray);
            //Take the raw video aspect ratio
            self.sourceWidth = self.video.videoWidth;
            self.sourceHeight = self.video.videoHeight;
            self.aspect = self.sourceWidth / self.sourceHeight;
            //self.snapToAspectRatio();
            //Init sliders
            self.volumeSlider.value = 0.5;
            self.seekBar.max = self.video.duration;  

            // Update frame size to video size     
            self.resetLayout();                          
            let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
            self.resizeFrame(scaleByPortrait, self.aspect);         

            self.playingCallback();   

            //fix resize bug
            $(window).off("resize");
            $(window).resize( function(){
                if (self.video.offsetWidth !== undefined){
                    //self.snapToAspectRatio();
                    // Update frame size to video size  
                    self.resetLayout();                  
                    
                    let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
                    self.resizeFrame(scaleByPortrait, self.aspect);

                    //resize the region boxes
                    // self.showAllRegions();                    
                }
            });

            //bind keys (note this currently overrides any listener on the parent controls needs a more elegant way to work only when control is in focus)
            if (self.keyUpEventsListenerBinded != null) {
                window.removeEventListener("keyup", self.keyUpEventsListenerBinded);
            }
            self.keyUpEventsListenerBinded = self.keyUpEventsListener.bind(self);        
            window.addEventListener("keyup", self.keyUpEventsListenerBinded, false);
        }

      this.video.onended = function(){
           self.pauseState();
      };
      this.video.addEventListener('canplaythrough', function () {
            self.updateFrameCanvas(self.video);
            /* window.requestAnimationFrame(function(){
                self.frameCanvas.getContext('2d').drawImage(self.video, 0, 0, self.frameWidth, self.frameHeight);
                }); */
        });

      this.seekBar.addEventListener("mousedown", function() {
            self.seeking = true;
          });
      this.seekBar.addEventListener("mouseup", function() {
            self.seeking = false;
          });
      this.seekBar.addEventListener("change", function() {
            self.seeking = false;
            if (self.imagelist){ //image list handling
                 var seekToFrameId =  Math.floor(self.seekBar.value);//keep the frame in sync
                 self.seekToFrame(seekToFrameId);
            } else { //video handling
                self.video.currentTime =  Math.floor(self.seekBar.value/self.frameTime) * self.frameTime;//keep the frame in sync 
            }
            self.playingCallback();
          });
      this.volumeSlider.addEventListener("change", function() {
            if (!self.imagelist){
                self.video.volume = self.volumeSlider.value;
                var perc =  100 * self.volumeSlider.value / self.volumeSlider.max;
                self.volumeStyle.textContent = '.volume::-webkit-slider-runnable-track{background-size:'+ perc +'% 100%} ';
                self.volumeStyle.textContent += '.volume::-moz-range-track{background-size:'+ perc +'% 100%} ';
            }
          });
      this.frameText.addEventListener("keydown", self.frameInputListener);
      this.frameText.addEventListener("keyup", self.frameInputListener);

      this.frameText.addEventListener("input", function(event) {
            if (self.imagelist){
                if(self.frameText.value > 0 && self.frameText.value <= self.imagelist.length) {
                    var seekToFrameId =  Math.min(self.imagelist.length, self.frameText.value);//keep the frame in sync
                    self.seekToFrame(seekToFrameId - 1);
                }
            } else {
                if(self.frameText.value > 0 && self.frameText.value <= (self.video.duration * self.framerate)) {
                    self.video.currentTime = ((self.frameText.value - 1) * self.frameTime) + self.videoStartTime;
                }
            }
            self.playingCallback();
            event.stopPropagation();
          });
      this.addEventListener("playSpeedSelected", function(e) {
            self.playback(e.detail.playbackValue, e.detail.playbackText);
          });
      
        this.addEventListener("ontagschanged", (tagsStateEvent) => {
            let tags = tagsStateEvent.detail.selected;
            let currentRegionUID = this.selectedRegionId[0];
            let region = this.getRegionById(currentRegionUID);
            if (tags.length > 0 && region != null) {
                let tagsDescriptor = this.buildTagsDescriptor(tags);
                region.tags = tags;
                this.regionsManager.updateTagsById(currentRegionUID, tagsDescriptor);
            } else {
                region.tags = [];
                this.regionsManager.updateTagsById(currentRegionUID, null);
            }

            this.selectRegion(currentRegionUID)
        });
      this.form.addEventListener("submit", function(e) {
        e.preventDefault();
        newTag = document.getElementById("newTag").value;
        self.inputtagsarray.push(newTag);
        self.optionalTags.createTagControls(self.inputtagsarray);
        self.showAllRegions();
      })
    },

    frameInputListener: function(event) {
        event.stopPropagation();
    },

    keyUpEventsListener: function(e) {
        switch (e.keyCode) {
            case 37:  // left
                if (!e.ctrlKey) {
                    this.stepBwdClicked();
                }
                break;
            case 39: // right
                if (!e.ctrlKey) {
                    this.stepFwdClicked();
                }            
                break;
            case 68:// d for duplicate
                if(e.ctrlKey) break;
                let frameId = this.getCurrentFrameId();
                if(this.imagelist){
                    frameId = this.imageIndex
                }
                if (frameId > 0) {
                    this.frames[this.getCurrentFrameId()] = this.getPrevFrameRegionsCopy();
                }
                this.playingCallback();
                break;
            case 32:// space to toggle play/pause
                this.playPauseClicked();
                break;
            case 81:// q to go back a frame
                if (!e.ctrlKey) {
                    this.stepBwdClicked();
                }
                break;
            case 69:// e to go forward a frame
                if (!e.ctrlKey) {
                    this.stepFwdClicked();
                }
                break;
            default: return; // exit this handler for other keys
            }
        e.preventDefault(); // prevent the default action (scroll / move caret)
    },

    keyUpEventsListenerBinded: null,

    onNewAreaSelected: function(x1, y1, x2, y2){
        var threshold = 20;
        var dx, dy;
        var r = {};
        if (x1 < x2) {
            r.x1 = x1;
            r.x2 = x2;
        } else {
            r.x1 = x2;
            r.x2 = x1;
        }

        if (y1 < y2) {
            r.y1 = y1;
            r.y2 = y2;
        } else {
            r.y1 = y2;
            r.y2 = y1;
        }

        dx = Math.abs(x1-x2);
        if (dx < threshold) {
            dx = (threshold - dx)/2
            r.x1 = Math.max(0, r.x1 - dx);
            r.x2 = Math.min(this.frameWidth, r.x2 + dx);
        }

        dy = Math.abs(y1-y2);
        if (dy < threshold) {
            dy = (threshold - dy)/2
            r.y1 = Math.max(0, r.y1 - dy);
            r.y2 = Math.min(this.frameHeight, r.y2 + dy);
        }

        this.createRegion(r.x1, r.y1, r.x2, r.y2);
    },

    generateUniqueId: function() {
        return Math.floor((1 + Math.random()) * 0x100000000)
            .toString(16)
            .substring(1);
    },

    getRegions: function(frameId) {
        let regions = null;
        if (frameId || frameId == 0) {
            regions = this.frames[frameId];

            if (regions == undefined || regions == null) {
                this.frames[frameId] = [];
                regions = this.frames[frameId];
            }
        }         

        return regions;
    },

    getCurrentFrameNumber: function() {
      if (this.imagelist){
        return this.imageIndex;
      } 
      return this.video.currentTime === 0 ? 1 : Math.ceil((this.video.currentTime - this.videoStartTime) * this.framerate) + 1 ;
    },

    getCurrentFrameId: function() {
      if (this.imagelist){
        return (this.imagelist[this.imageIndex].split(path.sep).pop());
      } 
      return this.video.currentTime === 0 ? 1 : Math.ceil((this.video.currentTime - this.videoStartTime) * this.framerate) + 1 ;
    },

    getCurrentFrameRegions: function() {   
        return this.getRegions(this.getCurrentFrameId());
    },

    getSelectedRegions: function() {
        return this.selectedRegionId.map(x =>  this.getRegionById(x))
    },

    getPrevFrameRegionsCopy: function() {
        if(this.imagelist){
            return JSON.parse(JSON.stringify(this.getRegions(this.imagelist[this.prevFrameIndex].split(path.sep).pop())));    
        } else {
            return JSON.parse(JSON.stringify(this.getRegions(this.prevFrameIndex)));
        }
    },

    getRegionById: function(regionUID) {
        let region = null;
        let regions = this.getCurrentFrameRegions();
        let i = 0;
        while (i < regions.length && region == null) {
                if (regions[i].UID == regionUID) {
                    region = regions[i];
                }
                i++
            }
        return region;
    },        

    createRegion: function(x1, y1, x2, y2) {
        let widthRatio = this.overlay.width / this.sourceWidth;
        let heightRatio = this.overlay.height / this.sourceHeight;

        var rx1 = x1 / widthRatio;
        var ry1 = y1 / heightRatio;
        var rx2 = x2 / widthRatio;
        var ry2 = y2 / heightRatio;

        var region = this.addRegion(rx1, ry1, rx2, ry2);//Add to in-memory collection
        this.registerRegion(x1, y1, x2, y2, region.UID, region.tags); //add frame

        //if there is only one tag enable it by default
        if ($(`#${this.optionalTags.id}`).find('.tagButtons').size() == 1){
            $(`#${this.optionalTags.id}`).find('.tagButtons')[0].click();
        }
        if(this.lockTagsEnabled) {
            //Get all selected tags and add them to current region automatically
            //this.selectedTags was populated in this.lockTagsClicked
            var arr = [];
            for (var i=0; i<this.selectedTags.length;i++) {
              this.optionalTags.setSelected(this.selectedTags[i]);
              arr.push(this.selectedTags[i].id);
            }
            this.addTagsToRegion(arr);
            var self = this;
            //Auto step functionality - Goes to next frame automatically
            if(this.multiregions === "0") {
                  setTimeout(function(){ self.stepFwdClicked(); }, 500);
            }
        }
        //this.emitRegionToHost();//Persist
    },
    //Adds new tags found in tfrecord to tags array
    addNewRecordTags: function(){
        let recs = []
        for(let tag of this.currTFRecord.features.feature["image/object/class/text"].bytesList.value){
            if(!this.inputtagsarray.includes(String.fromCharCode.apply(null, tag))) recs.push(String.fromCharCode.apply(null, tag));
        }
        if(recs.length) this.inputtagsarray.push.apply(this.inputtagsarray,recs)
    },
    checkRemovedTags: function() {
        let regions = this.getCurrentFrameRegions();
        regions.forEach(region => region.tags.forEach(tag => {
            if(!this.inputtagsarray.includes(tag)){
                region.tags.splice(tag,1);
            }
        }));
    },
    buildTagsDescriptor: function(tags) {

        
        let tagsDescriptor = null;
        let primaryTag = null;
        let secondaryTags = [];
        if (tags.length > 0) {
            let color = this.optionalTags.colors[this.inputtagsarray.indexOf(tags[0])];
            primaryTag = new this.CT.Base.Tags.Tag(tags[0], this.CT.Base.Tags.Tag.getHueFromColor(color) * 360);

            secondaryTags = [];
            for (var i = 1; i < tags.length; i++) {
                let c = this.optionalTags.colors[this.inputtagsarray.indexOf(tags[i])];
                let t = new this.CT.Base.Tags.Tag(tags[i], this.CT.Base.Tags.Tag.getHueFromColor(c) * 360);
                secondaryTags.push(t)
            }                

            tagsDescriptor = new this.CT.Base.Tags.TagsDescriptor(primaryTag, secondaryTags);
        }

        return tagsDescriptor;
    },

    addTagsToRegion: function(selectedTagsArray) {
        let currentRegion = this.selectedRegionId[0];
        let region = this.getRegionById(currentRegion);
        if (region != null) {
            let tags = region.tags;
            for (var i = 0; i < selectedTagsArray.length; i++) {
                tags.push(selectedTagsArray[i]);
            }

            if (tags.length > 0) {
                let tagsDescriptor = this.buildTagsDescriptor(tags);
                this.regionsManager.updateTagsById(region.UID, tagsDescriptor);
            } else {
                this.regionsManager.updateTagsById(region.UID, null);
            }
        }
    },
    nextUntaggedClicked:function() {
        if (this.checkRegionLabels()){
          var frameIndex = this.getCurrentFrameRegions();
            if (this.imagelist){//image handling
                var lastTagIndex = parseInt(Object.keys(this.frames)[Object.keys(this.frames).length-1])
                if (this.imageIndex < this.imagelist.length) {
                    if (lastTagIndex <= frameIndex){
                        this.imageIndex++;
                    } else {
                        this.imageIndex = lastTagIndex;
                    }
                    this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
                    this.playingCallback();
                }
            } else { //video handling
                var lastTagIndex = Object.keys(document.getElementById("video-tagging").frames).length;
                var nextFrameOffset = Math.max((lastTagIndex - frameIndex), 1);
                if(!this.video.paused) this.pauseState();
                if ((this.video.currentTime + this.frameTime) > this.video.duration ){
                    return;
                }
                if (!this.canMove ) return; 
                //if there are no unlabled tags move to next frame
                this.video.currentTime += this.frameTime * (nextFrameOffset);
                this.playingCallback();            
            }
        }
    },
    lockTagsClicked: function() {
        var selTags = this.optionalTags.getSelectedTags();
        //There has to be selected label/s
        if (!this.lockTagsEnabled && selTags.length > 0) {
            this.lockTagsEnabled = true;
            this.selectedTags = selTags;
            if(this.multiregions === "0"){this.stepFwdClicked();}
        }
        else {
            this.lockTagsEnabled = false;
            this.selectedTags = [];
            this.optionalTags.resetSelected();
        }
        this.lockTag.classList.toggle("controlOn", this.lockTagsEnabled);
        this.lockTag.classList.toggle("controlOff", !this.lockTagsEnabled);
    },

    regionMoved: function(id, x, y, width, height) {
        let region = this.getRegionById(id);

        let widthRatio = this.overlay.width / this.sourceWidth;
        let heightRatio = this.overlay.height / this.sourceHeight;

        var rx1 = x / widthRatio;
        var ry1 = y / heightRatio;
        var rx2 = (x + width) / widthRatio;
        var ry2 = (y + height) / heightRatio;
        
        // back compatibility for v < 2.0
        region.x1 = rx1;
        region.y1 = ry1;
        region.x2 = rx2;
        region.y2 = ry2;
        region.width = this.sourceWidth;
        region.height = this.sourceHeight;
        // coordinates for v 2.0+
        region.box = {
            x1: rx1,
            y1: ry1,
            x2: rx2,
            y2: ry2
        }
    },

    selectRegion: function(id, multiselection = false) {
        if(!this.multiselection && !multiselection){
            this.cleanSelectedElements();
        }

        //Tags - display the tags of the region and enable editing
        this.optionalTags.toggleEnableButtons(true);
        this.optionalTags.resetSelected();

        if (id != "") {
            let region = this.getRegionById(id);
            
            if(region && !this.selectedRegionId.includes(region.UID)) {
                this.selectedRegionId.push(id);
                
                var tags = region.tags;
                this.optionalTags.displaySelectedTags(tags);
            }
        }
    },

    selectAllRegions: function(){
        for(let region of this.getCurrentFrameRegions()){
          this.selectRegion(region.UID, true);
        }
    },

    deleteRegionById: function(id) {
        var regions = this.getCurrentFrameRegions();
        this.frames[this.getCurrentFrameId()] = regions.filter((r) => {return r.UID != id;});
        //this.emitRegionToHost();        
        if (id == this.selectedRegionId[0]) {
            this.selectedRegionId = [];
        }
    },

    clearRegions: function(e) {
          this.frames[this.getCurrentFrameId()]=[];
          this.clearAllRegions();
          // this.showAllRegions();
          //this.emitRegionToHost();
    },
    /**
       * @method emitRegionToHost
       * Fires an event to send the array of regions.
       * The host html page can listen to this event.
       */
    //emitRegionToHost: function() {
    //      this.fire('onregionchanged', {frame: {frameIndex: this.getCurrentFrameId(), regions:this.getCurrentFrameRegions()}});
    //},
    /**
       * @method addDivToRegion
       * Adds a transparent div to the region, the size of the region.
       * Used for click events, hover, etc..
       */
    registerRegion: function(x1, y1, x2, y2, regionUID, tags) {
        // Regions Manager
        let tagsDescriptor = this.buildTagsDescriptor(tags);
        
        this.regionsManager.addRegion(regionUID, {x:x1, y:y1}, {x:x2, y:y2}, tagsDescriptor);

        this.selectRegion(regionUID);
    },
    /**
       * @method cleanSelectedElements
       * Removes all borders of regions and disables label buttons
       */
    cleanSelectedElements: function() {
          //Remove selected style
          var regionCanvases = Polymer.dom(this.root).querySelectorAll('.regionCanvas');
          for (var i=0;i<regionCanvases.length;i++) {
            regionCanvases[i].classList.remove('regionCanvasSelected');
          }
          //reset
          this.selectedRegionId = [];
          this.optionalTags.toggleEnableButtons(false);
          this.optionalTags.resetSelected();
    },

    clearAllRegions: function() {
        // Regions Manager
        this.regionsManager.deleteAllRegions();

        // ** Old code **
        this.clearFrameElements();//Clear canvas and tags
        this.cleanSelectedElements();//Clear selected regions
    },

    showAllRegions: function() {
        this.clearAllRegions();
        var regions = this.getCurrentFrameRegions();
        if(regions && regions.length > 0) {
            this.checkRemovedTags();
            //Draw all regions for this frame
            for (var i=0; i<regions.length;i++) {
                var region = regions[i];
                //Frame was tagged as empty?
                if (Object.keys(region).length === 0) {
                    this.indicateEmptyFrame(true);
                    continue;
                }

                var widthRatio = this.overlay.width / this.sourceWidth;
                var heightRatio = this.overlay.height / this.sourceHeight;

                let x1, y1, x2, y2;
                if (region.box != undefined) {
                    // onscreen coordinates
                    x1 = (region.box.x1 * widthRatio);
                    y1 = (region.box.y1 * heightRatio);
                    x2 = (region.box.x2 * widthRatio);
                    y2 = (region.box.y2 * heightRatio);
                } else {
                    // restore absolute coordinates
                    let wRatio = this.sourceWidth / region.width;
                    let hRatio = this.sourceHeight / region.height;
                    x1 = (region.x1 * wRatio);
                    y1 = (region.y1 * hRatio);
                    x2 = (region.x2 * wRatio);
                    y2 = (region.y2 * hRatio);
                    region.box = {
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2
                    };
                    //onscreen coordinates
                    x1 = x1 * widthRatio;
                    y1 = y1 * heightRatio;
                    x2 = x2 * widthRatio;
                    y2 = y2 * heightRatio;
                }

                if (region.UID == undefined) {
                    region.UID = this.generateUniqueId();
                }
                
                this.registerRegion(x1, y1, x2, y2, region.UID, region.tags); ; //add frame                  
            }
            //Redraws all regions to ensure proper z-order stacking
            this.regionsManager.redrawAllRegions();
        }
        //Clears areaSelector state when moving across frames
        this.regionsManager.onManipulationEnd();
    },
    
    /**
       * @method addRegion
       * Adds a region to the array of regions per current frame.
       * @params {x1, y1, x2, y2} region coordinates.
       */
    addRegion: function(x1, y1, x2, y2) {
        this.resetEmptyFrame();//Clear empty frame logic
        
        var region = {
            // relative for back compatiblity (v < 2.0)
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            width: this.sourceWidth,
            height: this.sourceHeight,
            // absolute coordinates - new (v 2.0+)
            box: {
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2
            },
            UID: this.generateUniqueId(),
            id: this.uniqueTagId++,            
            type: this.regiontype,
            tags: []
        };
            
        var regions = this.getCurrentFrameRegions();
        //The array is populated and can contain multiple regions
        if(this.multiregions == 1 && regions) {
            region.name = regions.length + 1;
            regions.push(region);
        }
        else {//Only one region allowed
            this.clearFrameElements();
            region.name = 1;
            regions = [];
            regions.push(region);
        }
        return region;
    },
    /**
       * All functions related to frames management
       *
       * @method clearFrameElements
       * Clears all drawings and divs from the video area and resets tag controls.
       */
    clearFrameElements: function() {
      //Clear divs
      $(this.videoWrapper).children(".regionCanvas").remove();
      //reset tag buttons to not selected
      this.optionalTags.resetSelected();
      //Clears the empty frame icon
      this.indicateEmptyFrame(false);
    },

    indicateEmptyFrame : function(selected) {
        if(selected) {
            this.emptyFrame.classList.remove("controlOff");
            this.emptyFrame.classList.add("controlOn");
        }
        else {
            this.emptyFrame.classList.remove("controlOn");
            this.emptyFrame.classList.add("controlOff");
        }
    },
    /**
       * @method emptyFrameClicked
       * Creates an empty region array for the current frame, meaning that the frame is not tagged, but has been reviewed.
       */
    emptyFrameClicked: function() {
        var regions = this.getCurrentFrameRegions();
        if(!regions || regions.length === 0) {
            this.frames[frameIndex] = [{}];
            this.indicateEmptyFrame(true);
            // this.emitRegionToHost();
            if(this.lockTagsEnabled){
                this.stepFwdClicked();
            }
        }
    },
    /**
       * @method resetEmptyFrame
       * If the frame has been marked as empty - reset that.
       */
    resetEmptyFrame: function() {
        var regions = this.frames[this.getCurrentFrameId()];
        //If there is an empty region
        if(regions && regions.length === 1 && Object.keys(regions[0]).length === 0) {
            //reset all for this frame
            this.frames[this.getCurrentFrameId()] = [];
            this.clearFrameElements();
        }
    },
    /**
       * Video management
       *
       */
    muteClicked: function() {
          this.mute.classList.toggle("icon-volume-mute2", !this.video.muted);
          this.mute.classList.toggle("icon-volume-medium", this.video.muted);
          this.video.muted = !this.video.muted;
    },
    /**
       * Handler for setting the video play speed
       */
    playback: function(val, text) {
          if(val !== null){
              this.video.playbackRate = val;
              this.playbackSpan.innerHTML = text;
          }
          this.playSpeedControl.style.display = "block";
    },
    /**
       * Shows the play speed control
       */
    playbackSpeedClicked: function() {
          var offset = $('#playSpeedCell').offset();
          var top = offset.top - $('#playSpeedControl').height();
          var left = offset.left + $('#playSpeedCell').width() / 4;
          $('#playSpeedControl').css({'left': left, 'top': top});
          this.playSpeedControl.style.display = this.playSpeedControl.style.display === "block"?"none":"block";
    },
    playPauseClicked: function() {
        if(this.imagelist) //Play back image sequence
        {
           this.sequencePlaying ? this.pauseState():this.playState();
        } else { //Play back video
            this.video.paused ? this.playState():this.pauseState();
        }
    },
    getUnlabeledRegionTags: function(regionId){
         var regions = this.frames[regionId];
         var unlabledTags = [];
         if (regions !== undefined){
            unlabledTags = regions.map(function(region,index){
                if (!region.tags.length > 0) return index + 1;
         }).filter(Number.isInteger);
        }
        return unlabledTags;
    },
    checkRegionLabels: function(){
        var unlabledTags = this.getUnlabeledRegionTags(this.getCurrentFrameId());
        if (unlabledTags.length > 0){
            alert(`Cannot move to the next frame until all tags are labeled. Please label the following tags [${unlabledTags}] on the displayed frame.`);
            return false;
        }
        return true;
    },
    //used for init of image directory find way to reduce duplicate code
    initImageDir: function() {
        if (!this.imagelist){

        }
        //$("#rotate").show();
        if(this.recordlist) {this.currTFRecord = this.recordlist[0]; this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true);}
        else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`); 
        console.log(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
        var self = this;
        self.frames = self.inputframes? self.inputframes:{};
        if(this.currTFRecord) this.addNewRecordTags();
        self.optionalTags.createTagControls(this.inputtagsarray);

        //self.resetLayout();
        
        //bind keys (note this currently overrides any listener on the parent controls needs a more elegant way to work only when control is in focus)
        if (self.keyUpEventsListenerBinded != null) {
                window.removeEventListener("keyup", self.keyUpEventsListenerBinded);
            }
        self.keyUpEventsListenerBinded = self.keyUpEventsListener.bind(self);        
        window.addEventListener("keyup", self.keyUpEventsListenerBinded, false); 
    },
    changeImage: function(imageUrl, isRecord = false){

        if(isRecord){
            let base64Data = btoa(new Uint8Array(imageUrl).reduce(function (data, byte) {
                                return data + String.fromCharCode(byte);
                            }, ''));
            this.video.style.backgroundImage = encodeURI('data:image/png;base64,' + {base64Data});
            this.curImg.src = `${'data:image/png;base64,' + base64Data}`;
        } else {
            this.video.style.backgroundImage = encodeURI(imageUrl);
            this.curImg.src = `${this.imagelist[this.imageIndex]}`;
        }

        this.rotation = 0;
        var self = this;

        self.curImg.onload = function() {
            self.controlWrapper.style.display = "grid";
            self.sourceWidth = self.curImg.width;
            self.sourceHeight = self.curImg.height;
            self.aspect = self.sourceWidth / self.sourceHeight;
            //Size canvas as image
            let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
            
            self.resizeFrame(scaleByPortrait, self.aspect);

            //Init variables and controls
            self.playingCallback();

            //fix resize bug
            $(window).off("resize");
            $(window).resize(function(){
                if (self.video.offsetWidth !== undefined){
                    //self.snapToAspectRatio();

                    let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
                    self.resizeFrame(scaleByPortrait, self.aspect);
                    
                    //resize the region boxes
                    //self.showAllRegions();
                    //reposition selectedRegion Label
                    self.playingCallback();
                }
            });
        }

    },

    resizeFrame(isPortrait, imgRatio) {
        if (isPortrait) {
            this.resizeFrameSize(parseFloat(this.video.offsetHeight * imgRatio), this.video.offsetHeight);
            //shift the overlay
            var leftShift = `${((this.video.offsetWidth/2) - (this.overlay.width/2))}px`;
            this.overlay.style.left = leftShift;
            this.overlay.style.top  = '0px';

            this.frameCanvas.style.margin = "0px " + leftShift; 
            this.selectionSVG.style.margin = "0px " + leftShift;  

        } else {
            this.resizeFrameSize(this.video.offsetWidth, parseFloat(this.video.offsetWidth / imgRatio));
            //shift the overlay
            var topShift = `${((this.video.offsetHeight/2) - (this.overlay.height/2))}px`
            this.overlay.style.top = topShift;
            this.overlay.style.left  = '0px';

            this.frameCanvas.style.margin = topShift + " 0px"; 
            this.selectionSVG.style.margin = topShift + " 0px"; 
        }
    },

    resizeFrameSize: function(width, height) {
        this.frameWidth = width;
        this.frameHeight = height;

        this.overlay.width = this.frameWidth;
        this.overlay.height = this.frameHeight;
                        
        this.frameCanvas.width = this.frameWidth;
        this.frameCanvas.height = this.frameHeight;

        this.areaSelector.resize(width, height);
        this.regionsManager.resize(width, height);
    },

    resetLayout: function(){
        this.overlay.style.top = "";
        this.overlay.style.left = "";
        this.frameCanvas.style.margin = "";
        this.selectionSVG.style.margin = "";
    },

    disableImageDir: function() {       
        $("#rotate").hide(); 
        $(window).off("resize");
        this.imageIndex = 0;
        this.imagelist = undefined;
        this.video.removeAttribute("poster");
        this.src = "";
    },

    rotate: function() {
        this.rotation = (this.rotation + 90) % 360;
        $('#vid').css("transform",`rotate(${this.rotation}deg)`);   
    },
    seekToFrame: function(id, fireEvents = true) {
        if (this.checkRegionLabels()){
            //raise before next frame
            this.prevFrameIndex = this.getCurrentFrameNumber();  
            if (this.imagelist){//image handling
                if(this.imageIndex == id - 1) {
                    //Only fire before step if seeking to the next frame
                    if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-BeforeStep');    
                }
                if(this.imageIndex == id + 1) {
                    //Only fire before step if seeking to the previous frame
                    if(fireEvents)$('#video-tagging').trigger('stepBwdClicked-BeforeStep');    
                }
                if (id < this.imagelist.length-1) {
                    this.imageIndex = id;
                    if(this.recordlist) {
                        this.currTFRecord = this.recordlist[this.imageIndex];
                        this.addNewRecordTags();
                        this.optionalTags.createTagControls(this.inputtagsarray);
                        this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true);
                    }
                    else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
                    //this.playingCallback();
                }
            } else { //video handling
                //TODO: This is never called, so why is it here?
                if(!this.video.paused) this.pauseState();
                if ((this.video.currentTime + this.frameTime) > this.video.duration ){
                    //this.video.currentTime = this.video.duration;
                    return;
                }
                if (!this.canMove ) return; 
                if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-BeforeStep');    
                //if there are no unlabled tags move to next frame
                this.video.currentTime += this.frameTime;
                this.playingCallback();            
            } 
            //raise after next frame
            if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-AfterStep');

        }
    },
    stepFwdClicked: function(fireEvents = true) {       
        if (this.checkRegionLabels()){
            this.prevFrameIndex = this.getCurrentFrameNumber();
            this.cleanSelectedElements()
            //raise before next frame
            if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-BeforeStep');    
            if (this.imagelist){//image handling 
                if (this.imageIndex < this.imagelist.length-1) {
                    this.imageIndex++;
                    if(this.recordlist){
                        this.currTFRecord = this.recordlist[this.imageIndex];
                        if(this.currTFRecord) this.addNewRecordTags();
                        this.optionalTags.createTagControls(this.inputtagsarray);
                        this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true);
                    }
                    else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
                }
            } else { //video handling
                if(!this.video.paused) this.pauseState();
                if ((this.video.currentTime + this.frameTime) > this.video.duration ){
                    return;
                }
                //if there are no unlabled tags move to next frame
                this.video.currentTime += this.frameTime;
                this.playingCallback();
            } 
            //raise after next frame
            if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-AfterStep');

        }
    },
    stepBwdClicked: function(fireEvents = true) {
        if (this.checkRegionLabels()){
            this.prevFrameIndex = this.getCurrentFrameNumber();    
            this.cleanSelectedElements();
            if(fireEvents)$('#video-tagging').trigger('stepBwdClicked-BeforeStep'); 
            if (this.imagelist){//image handling
                if (this.imageIndex > 0) {
                    this.imageIndex--;
                    if(this.recordlist) {
                        this.currTFRecord = this.recordlist[this.imageIndex];
                        this.addNewRecordTags();
                        this.optionalTags.createTagControls(this.inputtagsarray);
                        this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true);
                }
                    else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
                }
            } 
            if (this.video.currentTime > 0) {
                if(!this.video.paused) {
                this.pauseState();
                }
                if (this.checkRegionLabels()){
                this.video.currentTime -= this.frameTime;
                this.playingCallback();
                }
            }
            if(fireEvents)$('#video-tagging').trigger('stepBwdClicked-AfterStep');
        }    
    },
    videoSrcChanged: function(newValue, oldValue) {
          if(this.video){
             if (this.imagelist){
                this.initImageDir();
             } else{
                this.video.src = newValue;
                this.video.style.backgroundImage = null;
             }
          }
    },
    videoClicked: function(e) {
            this.cleanSelectedElements();
            if(!((this.regiontype.toLowerCase() === "square") || (this.regiontype.toLowerCase() === "rectangle")))
            {
                var rect = this.overlay.getBoundingClientRect();
                var x1 = (e.clientX-rect.left)/(rect.right-rect.left)*this.overlay.width;
                var y1 = (e.clientY-rect.top)/(rect.bottom-rect.top)*this.overlay.height;
                this.createRegion(x1, y1, null, null);
            }
    },
    playState: function() {
        if(!this.imagelist) {
            this.video.play();
            this.playing = setInterval(function() {
                self.playingCallback();
            }, 10);
        } else {
            this.sequencePlaying = true;
            this.playing = setInterval(function() {
                self.playImageSquence();
            }, 33);
        }
        this.playButton.classList.toggle("icon-pause2", !this.video.paused || this.sequencePlaying);
        //Reset lock tags to off
        this.lockTagsEnabled = true;
        this.lockTagsClicked();
        this.optionalTags.toggleEnableButtons(false);
        // $('canvas#overlay').imgAreaSelect({disable: true});//disable canvas
        var self = this;
        
    },
    pauseState: function() {
        if(!this.imagelist) {
            this.video.pause();

            this.video.currentTime =  Math.floor(this.video.currentTime/this.frameTime) * this.frameTime;//keep the frame in sync
        } else {
            this.sequencePlaying = false;
        }
        clearInterval(this.playing);
        this.playingCallback();
        this.playButton.classList.toggle("icon-pause2", !this.video.paused || this.sequencePlaying);
        this.optionalTags.toggleEnableButtons(false);
        // $('canvas#overlay').imgAreaSelect({disable: false});//enable canvas
    },
    playingCallback: function() { 
        if (!this.imagelist){
            this.frameText.value = this.getCurrentFrameNumber();
            this.displayVideoTime();
            if(!this.seeking){
                this.updateSeekBar();
            }
            // Update canvas image based on new video frame
            this.updateFrameCanvas(this.video);

        } else{
            this.frameText.value = `${this.getCurrentFrameNumber() + 1}`;
            if(!this.seeking){
                this.updateSeekBar();
            }
            // Update canvas image based on new video frame
            this.updateFrameCanvas(this.curImg);
        }           
        this.showAllRegions();
    },
    playImageSquence: function() {
        if(this.imageIndex == this.imagelist.length - 1){
            this.pauseState();
        } 
        if(this.sequencePlaying) {
            this.stepFwdClicked();
        }
    },
    displayVideoTime: function() {
            var currentTime = Math.round(this.video.currentTime);
            var remainingtTime = Math.round(this.video.duration - this.video.currentTime);
            //Format using moment.js
            currentTime = moment().startOf('day').seconds(currentTime).format('HH:mm:ss');
            remainingtTime = moment().startOf('day').seconds(remainingtTime).format('HH:mm:ss');
            this.timeSpan.innerHTML = currentTime + "  /  " + remainingtTime;
    },
    updateSeekBar: function() {
            if (this.imagelist){ //image list handling
                if(!this.seekBar.max)
                    this.seekBar.max = this.imagelist.length-1;
                this.seekBar.value = this.getCurrentFrameNumber();
            } else { //video handling
                this.seekBar.value = this.video.currentTime;
            }
            var perc =  100 * this.seekBar.value / this.seekBar.max;
            this.seekStyle.textContent =  '.seek::-webkit-slider-runnable-track{background-size:'+perc+'% 100%}';
            this.seekStyle.textContent += '.seek::-moz-range-track{background-size:'+perc+'% 100%}';
    },
    updateFrameCanvas: function(source) {
        var context = this.frameCanvas.getContext('2d');
        var self = this;
        if (source instanceof HTMLVideoElement || source instanceof HTMLImageElement) {
            var buff = document.createElement('canvas');
            buff.width = this.frameWidth;
            buff.height = this.frameHeight;
            buff.getContext('2d').drawImage(source, 0, 0, this.frameWidth, this.frameHeight);

            this.filterPipeline.applyToCanvas(buff).then((bcnvs) => {
                // Copy buffer to the canvas on screen
                this.frameCanvas.width = bcnvs.width;
                this.frameCanvas.height = bcnvs.height;
                let imgContext = this.frameCanvas.getContext("2d");
                imgContext.drawImage(bcnvs, 0, 0, bcnvs.width, bcnvs.height);
            });
        }
    },

    addFilterByName(filterName, params) {
        switch (filterName) {            
            case "invert_filter": {
                this.filterPipeline.addFilter(this.CT.Filter.InvertFilter);
                this.playingCallback();
                break;
            }
            case "grayscale_filter": {
                this.filterPipeline.addFilter(this.CT.Filter.GrayscaleFilter);
                this.playingCallback();
                break;
            }
            case "reset": {
                this.filterPipeline.clearPipeline();
                this.playingCallback();
                break;
            }

            default: {

            }

        }
    }
});
</script>
<script src="../jquery/dist/jquery.min.js"></script>
<script src="../moment/moment.js"></script>
<script src="js/jquery.imgareaselect.js"></script>
<script src="../jquery-ui/jquery-ui.min.js"></script>
<!-- <script src="js/ct.min.js"></script> -->
<script src="js/ct.js"></script>
</dom-module>
